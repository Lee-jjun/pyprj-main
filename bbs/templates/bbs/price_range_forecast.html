{% extends 'bbs/base.html' %}
{% load static %}

{% block title %}가격대별 전월세 예측{% endblock %}

{% block content %}

<style>
    /* 웹 페이지 전체 디자인 변수 */
    :root {
        --body-bg: #fdfdfd;
        --container-bg: #fff;
        --main-text: #4a4a4a;
        --heading-text: #2c3e50;
        --border-color: #e0e0e0;
        --code-bg: #f8f9fa;
        --code-text: #5a5a5a;
        --accent-color: #007bff;
        --link-hover: #0056b3;
    }
    
    body {
        background-image: url("{% static 'images/apt7.jpg' %}");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        font-family: 'Apple SD Gothic Neo', 'Malgun Gothic', '맑은 고딕', Arial, sans-serif;
        line-height: 1.6;
        color: var(--main-text);
        margin: 0;
        padding: 0;
    }

    .notebook-container {
        padding: 40px 20px;
        max-width: 900px;
        margin: 0 auto;
    }

    .title {
        display: flex;
        justify-content: center;   /* 가로 중앙 */
        align-items: center;       /* 세로 중앙 */
        flex-direction: column;    /* 세로 정렬 (여러 줄일 경우) */
        width: 550px;
        margin: 50px auto;         /* 화면 가운데 정렬 */
        padding: 20px 30px;
        color: #fff;
        font-size: 2.5rem;
        font-weight: bold;
        letter-spacing: -1px;
        text-align: center;        /* 텍스트 중앙 정렬 */
        text-decoration: none;
        background: rgba(255, 255, 255, 0.25);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 20px;
        text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.6);
    }

    /* 셀 컨테이너 */
    .cell {
        background-color: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        margin-bottom: 30px;
        overflow: visible;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .cell:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
    }

    /* 코드 셀 스타일 */
    .code-cell {
        background-color: var(--code-bg);
        padding: 20px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
        /* overflow-x: auto; */
        border-left: 4px solid var(--accent-color);
    }

    .code-cell pre {
        margin: 0;
        white-space: pre-wrap;
    }
    
    .code-cell h3 {
        color: var(--heading-text);
        font-size: 1.2rem;
        font-weight: 600;
        margin-top: 0;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px dashed var(--border-color);
    }

    /* 결과 출력 셀 스타일 */
    .output-cell {
        padding: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
        border-top: none;
        text-align: center;
        overflow: visible;
    }

    .output-cell h3, .output-cell h4 {
        font-weight: 600;
        margin: 0;
    }
    
    .output-cell h3 { font-size: 1.5rem; }
    .output-cell h4 { font-size: 1.1rem; }

    .result-image {
        max-width: 100%;
        height: auto;
        border-radius: 6px;
        border: 1px solid #ddd;
        transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        position: relative; /* z-index를 위해 필수 */
        z-index: 1; /* 평상시 z-index */
        /* transform-origin을 명시하여 확대 중심점 설정 */
        transform-origin: center center;
    }

    .result-image:hover {
        transform: scale(1.6); /* 확대 비율을 약간 줄여 테스트 */
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 10; /* 호버 시 가장 앞으로 */
    }

    .result-image1 {
        max-width: 100%;
        height: auto;
        border-radius: 6px;
        border: 1px solid #ddd;
        transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        position: relative; /* z-index를 위해 필수 */
        z-index: 1; /* 평상시 z-index */
        /* transform-origin을 명시하여 확대 중심점 설정 */
        transform-origin: center center;
    }

    .result-image1:hover {
        transform: scale(1.2); /* 확대 비율을 약간 줄여 테스트 */
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 10; /* 호버 시 가장 앞으로 */
    }
   
    .result-image2 {
        max-width: 100%;
        height: auto;
        border-radius: 6px;
        border: 1px solid #ddd;
        transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        position: relative; /* z-index를 위해 필수 */
        z-index: 1; /* 평상시 z-index */
        /* transform-origin을 명시하여 확대 중심점 설정 */
        transform-origin: center center;
    }

    .result-image2:hover {
        transform: scale(1.0); /* 확대 비율을 약간 줄여 테스트 */
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 10; /* 호버 시 가장 앞으로 */
    }

    /* 테이블 컨테이너 스타일 */
    .table-container {
        width: 100%;
        overflow-x: hidden;
        border: none;
    }

    .table-container table {
        width: 100%;
        table-layout: fixed;
        font-size: 0.7rem;
        border-collapse: collapse;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }

    .table-container th, 
    .table-container td {
        padding: 4px;
        text-align: left;
        border: none;
        word-wrap: break-word;
    }

    .table-container th {
        background-color: #f7f7f7;
        font-weight: 600;
    }

    /* 구별 군집 분류 데이터 전용 스타일 (작고 깔끔한 디자인) */
    #cluster-table-container {
        width: 100%;
        max-width: 100%; /* 부모 컨테이너 너비를 넘지 않도록 설정 */
        overflow-x: auto; /* 내용이 넘치면 스크롤바 생성 */
        border: none; /* 외부 테두리 제거 */
        border-radius: 8px; /* 살짝 둥근 모서리 */
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); /* 은은한 그림자 */
        background-color: var(--container-bg);
        padding: 0; /* 내부 패딩 제거 */
        display: block;
        margin: 20px auto; /* 중앙 정렬 및 위아래 여백 */
    }
    
    #cluster-table-container table {
        width: 100%;
        border-collapse: collapse; /* 셀 테두리 병합 */
        font-size: 0.75rem; /* 글자 크기 약간 작게 */
        color: var(--main-text);
        table-layout: auto; /* 내용에 따라 열 너비 자동 조정 */
        min-width: 600px; /* 최소 너비를 지정하여 너무 좁아지는 것 방지 */
    }

    #cluster-table-container th, 
    #cluster-table-container td {
        padding: 8px 12px; /* 셀 내부 여백 줄이기 */
        text-align: left;
        border-bottom: 1px solid #eee; /* 얇은 하단 구분선 */
        white-space: nowrap; /* 줄바꿈 방지 */
        overflow: hidden;
        text-overflow: ellipsis; /* 내용이 넘치면 ...으로 표시 */
        max-width: 150px; /* 셀 최대 너비 지정 (선택 사항, 필요시 조정) */
    }

    #cluster-table-container th {
        background-color: #fcfcfc; /* 헤더 배경색 아주 연하게 */
        color: var(--heading-text);
        font-weight: 500; /* 헤더 폰트 굵기 약간 줄임 */
        border-bottom: 2px solid #ddd; /* 헤더 하단에 더 진한 구분선 */
    }

    #cluster-table-container tr:last-child td {
        border-bottom: none; /* 마지막 행 하단선 제거 */
    }

    #cluster-table-container tr:nth-child(even) {
        background-color: #f9f9f9; /* 짝수 행 배경색 지정 (얼터네이팅 로우) */
    }
    
    #cluster-table-container tr:hover {
        background-color: #f0f8ff; /* 호버 시 아주 연한 파란색 배경 */
    }
    
    /* 첫 번째 열(구 이름) 스타일 */
    #cluster-table-container td:first-child {
        font-weight: 600; /* 구 이름 강조 */
        color: #34495e; /* 약간 더 어두운 색상 */
    }

    /* 금액대 열 (세 번째 열) 오른쪽 정렬 */
    #cluster-table-container th:nth-child(3),
    #cluster-table-container td:nth-child(3) {
        text-align: center;
    }

    /* 마지막 열 (클러스터) 가운데 정렬 */
    #cluster-table-container th:last-child,
    #cluster-table-container td:last-child {
        text-align: center;
    }

    /* 정확도 목록 컨테이너 스타일 */
    .accuracy-list {
        width: 100%;
        margin-top: 30px;
        border: none;
        border-radius: 6px;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .accuracy-list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-color);
        transition: background-color 0.2s ease;
    }
    
    .accuracy-list-item:hover {
        background-color: #f9f9f9;
    }
    
    .accuracy-list-item:last-child {
        border-bottom: none;
    }
    
    .accuracy-list-item h4 {
        color: var(--heading-text);
        font-size: 1.1rem;
        font-weight: 600;
        margin: 0;
    }
    
    .accuracy-list-item p {
        font-size: 1.1rem;
        font-weight: 500;
        color: var(--main-text);
        margin: 0;
    }

    /* 구 버튼 스타일 */
    .gu-button {
        background-color: transparent;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        color: var(--heading-text);
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        padding: 8px 15px;
        transition: all 0.2s ease;
    }

    .gu-button.active, .gu-button:hover {
        background-color: var(--accent-color);
        color: #fff;
        border-color: var(--accent-color);
    }
    
    /* 에러 메시지 스타일 */
    .error-message {
        color: #c0392b;
        font-weight: bold;
        padding: 25px;
        border: 2px solid #e74c3c;
        border-radius: 8px;
        background-color: #fdeded;
        text-align: center;
    }

    /* 결과 없음 메시지 스타일 */
    .no-result-message {
        color: #7f8c8d;
        font-size: 1.2rem;
        text-align: center;
        padding: 30px;
    }
    
    /* 링크 스타일 */
    a {
        color: var(--accent-color);
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    a:hover {
        color: var(--link-hover);
    }
    
    /* 테이블 버튼 컨테이너 (버튼을 나란히 배치) */
    .table-button-container {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
        width: 100%;
        margin-top: 10px;
    }
    
    /* 각 테이블 섹션 (개별 버튼과 표를 감쌈) */
    .table-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        min-width: 300px;
        text-align: center;
    }
    
    /* 표 컨테이너 (가운데 정렬) */
    #jeonse-table-container,
    #wolse-table-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    /* 모델 버튼 컨테이너 */
    .model-button-container {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
    }

    /* 반응형 디자인 */
    @media (max-width: 768px) {
        .notebook-container { padding: 20px 10px; }
        .title { font-size: 2rem; margin-bottom: 30px; }
        .cell { margin-bottom: 20px; }
        .table-button-container { flex-direction: column; align-items: center; }
        .table-section { width: 100%; }
    }
</style>


<div class="notebook-container">
    <h1 class="title">금액대별 구별 수요량 예측 </h1>
    
    {% if result %}
        {{ result.prophet|json_script:"prophet_data" }}
        {{ result.linear_regression|json_script:"linear_regression_data" }}
        {{ result.random_forest|json_script:"random_forest_data" }}
    
        {% if 'ERROR' in result %}
            <div class="cell error-message">
                <p><strong>오류 발생:</strong> {{ result.ERROR }}</p>
                <p>예측 결과를 불러오는 데 문제가 발생했습니다. 관리자에게 문의하세요.</p>
            </div>
        {% else %}
            <div class="cell">
                <div class="code-cell">
                    <h3>라이브러리 import 및 Matplotlib 설정</h3>
                    <pre><code class="language-python">
import os
import io
import base64
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib as mpl
import matplotlib.pyplot as plt
from prophet import Prophet
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
import time
mpl.use('Agg')  # 비대화형 백엔드로 설정
                    </code></pre>
                </div>
            </div>
            
            <div class="cell">
                <div class="code-cell">
                    <h3>구별/금액대별 수요량 분석 및 시각화</h3>
                    <pre><code class="language-python">
# 데이터 전처리 및 금액대 분류
df['구'] = df['시군구'].apply(lambda x: x.split()[1] if len(x.split()) > 1 else None)
df.dropna(subset=['구'], inplace=True)
df = df[['시군구', '전월세구분', '보증금(만원)', '월세금(만원)', '계약년월', '구']]
df['보증금(만원)'] = pd.to_numeric(df['보증금(만원)'].str.replace(',', '', regex=True).fillna('0'))
df['월세금(만원)'] = pd.to_numeric(df['월세금(만원)'].str.replace(',', '', regex=True).fillna('0'))
df['환산보증금'] = df.apply(
    lambda row: row['보증금(만원)'] + row['월세금(만원)'] * 100 if row['전월세구분'] == '월세' else row['보증금(만원)'], axis=1
)
df = df[df['환산보증금'] <= 200000]
bins = list(range(0, int(df['환산보증금'].max()) + 10000, 10000))
labels = [f'{i // 10000}억~{(i + 10000) // 10000}억' for i in range(0, int(df['환산보증금'].max()) + 10000, 10000)[:-1]]
df['금액대'] = pd.cut(df['환산보증금'], bins=bins, labels=labels, right=False)
df['계약년월'] = pd.to_datetime(df['계약년월'].astype(str), format='%Y%m')

plt.rcParams['font.family'] = 'Malgun Gothic'
mpl.rcParams['axes.unicode_minus'] = False

# 전세와 월세 데이터 분리
df_jeonse = df[df['전월세구분'] == '전세'].copy()
df_wolse = df[df['전월세구분'] == '월세'].copy()

# 구별, 금액대별 수요량 분석
demand_jeonse = df_jeonse.groupby(['구', '금액대']).size().unstack(fill_value=0)
demand_wolse = df_wolse.groupby(['구', '금액대']).size().unstack(fill_value=0)
                    </code></pre>
                <div class="output-cell">
                    <h4>구별 전월세 수요량 데이터</h4> 
                    
                    <div class="table-button-container">
                        <button id="show-jeonse-btn" class="gu-button">전세 데이터 출력</button>
                        <button id="show-wolse-btn" class="gu-button">월세 데이터 출력</button>
                    </div>

                    <div id="jeonse-table-container" style="display: none;">
                        <h4>전세 수요량 데이터</h4>
                        <div class="table-container">
                            {{ result.demand_jeonse_html|safe }}
                        </div>
                    </div>
                    
                    <div id="wolse-table-container" style="display: none;">
                        <h4>월세 수요량 데이터</h4>
                        <div class="table-container">
                            {{ result.demand_wolse_html|safe }}
                        </div>
                    </div>
                    <h3>구별 수요량 분석 결과</h3>
                    <a href="{{ result.images.0 }}" target="_blank">                     
                        <img src="{{ result.images.0 }}" alt="구별 수요량 히트맵" class="result-image">
                    </a>
                </div>
            </div>
        </div>
            <div class="cell">
                <div class="code-cell">
                    <h3>구별 수요 패턴 군집화 (K-Means + PCA)</h3>
                    <pre><code class="language-python">
# 구별 수요 패턴 데이터 준비
df['계약년월'] = pd.to_datetime(df['계약년월'].astype(str), format='%Y%m')
demand_by_gu = df.groupby(['구', '금액대']).size().unstack(fill_value=0)
                        
# K-Means 및 PCA를 사용한 군집화
scaler = StandardScaler()
scaled_demand = scaler.fit_transform(demand_by_gu)
optimal_k = 4
kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init='auto')
demand_by_gu['cluster'] = kmeans.fit_predict(scaled_demand)
pca = PCA(n_components=2)
reduced_data = pca.fit_transform(scaled_demand)
                    </code></pre>
                </div>
                <div class="output-cell">
                    <h4>구별 군집 분류 데이터</h4>
                    <div id="cluster-table-container">
                        {{ result.cluster_html|safe }}
                    </div>
                    <br>
                    <h3>구별 수요 패턴 군집화 결과</h3>
                    <a href="{{ result.images.1 }}" target="_blank">
                        <img src="{{ result.images.1 }}" alt="구별 수요 패턴 군집화" class="result-image1">
                    </a>
                </div>
            </div>

            {% if result.prophet or result.linear_regression or result.random_forest %}
            <div class="cell">
                <div class="code-cell">
                    <h3>Prophet, linear_regression, random_forest 모델 예측 &amp; 정확도 평가</h3>
                    <pre><code class="language-python">
# 각 모델별 예측 및 정확도 지표 반환 로직
# (Prophet, 선형 회귀, 랜덤 포레스트)
for gu in gu_list:
    gu_data = time_series_data[time_series_data['구'] == gu].copy()
    gu_data['ds'] = gu_data['계약년월']
    gu_data['y'] = gu_data['거래건수']

# Prophet 모델 예측
    try:
        m = Prophet(seasonality_mode='multiplicative', daily_seasonality=False)
        m.fit(gu_data.iloc[:-3][['ds', 'y']])
        # future = m.make_future_dataframe(periods=3, freq='M')
        future_dates = pd.to_datetime(['2023-08-01', '2023-09-01', '2023-10-01'])
        future = pd.DataFrame({'ds': future_dates})
        forecast = m.predict(future)
        y_true = gu_data['y'].iloc[-3:].values
        y_pred = forecast['yhat'].iloc[-3:].values
                    
        mae = mean_absolute_error(y_true, y_pred)
        rmse = np.sqrt(mean_squared_error(y_true, y_pred))
        mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100 if np.all(y_true != 0) else float('inf')
                    
        prophet_results['accuracy'][gu] = {'MAE': mae, 'RMSE': rmse, 'MAPE': mape}

# 선형 회귀 모델 예측
    try:
        gu_data['time_idx'] = (gu_data['ds'] - gu_data['ds'].min()).dt.days
        X_train = gu_data[['time_idx']].iloc[:-3]
        y_train = gu_data['y'].iloc[:-3]
        X_test = gu_data[['time_idx']].iloc[-3:]
                        
        model_lr = LinearRegression()
        model_lr.fit(X_train, y_train)
        y_pred = model_lr.predict(X_test)
                        
        y_true = gu_data['y'].iloc[-3:].values
                        
        mae = mean_absolute_error(y_true, y_pred)
        rmse = np.sqrt(mean_squared_error(y_true, y_pred))
        mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100 if np.all(y_true != 0) else float('inf')
                        
        linear_regression_results['accuracy'][gu] = {'MAE': mae, 'RMSE': rmse, 'MAPE': mape}

# 랜덤 포레스트 회귀 모델 예측
    try:
        gu_data['time_idx'] = (gu_data['ds'] - gu_data['ds'].min()).dt.days
        X_train = gu_data[['time_idx']].iloc[:-3]
        y_train = gu_data['y'].iloc[:-3]
        X_test = gu_data[['time_idx']].iloc[-3:]
                    
        model_rf = RandomForestRegressor(n_estimators=100, random_state=42)
        model_rf.fit(X_train, y_train)
        y_pred = model_rf.predict(X_test)
                    
        y_true = gu_data['y'].iloc[-3:].values
                    
        mae = mean_absolute_error(y_true, y_pred)
        rmse = np.sqrt(mean_squared_error(y_true, y_pred))
        mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100 if np.all(y_true != 0) else float('inf')
                    
        random_forest_results['accuracy'][gu] = {'MAE': mae, 'RMSE': rmse, 'MAPE': mape}
                    


                    </code></pre>
                </div>
                <div class="output-cell" style="gap: 50px;">
                    <h3>모델별 예측 결과 및 정확도 비교</h3>
                    <div class="model-button-container">
                        <button class="gu-button model-button" data-model="prophet">Prophet</button>
                        <button class="gu-button model-button" data-model="linear_regression">linear regression</button>
                        <button class="gu-button model-button" data-model="random_forest">random forest</button>
                    </div>

                    <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;">
                        {% for gu in result.prophet.accuracy %}
                            <button class="gu-button select-gu-button" data-gu="{{ gu }}">
                                {{ gu }}
                            </button>
                        {% endfor %}
                    </div>
                    
                    <div class="accuracy-graph-container" style="display: none;">
                        <h4 id="gu-name"></h4>
                        <img id="prediction-graph" src="" alt="예측 그래프" class="result-image2">
                        <div id="accuracy-metrics" class="accuracy-list"></div>
                    </div>

                    <div id="initial-message" style="text-align: center;">
                        <p style="font-size: 1.2rem; color: #7f8c8d;">
                            모델과 구를 선택하여 예측 결과와 정확도 지표를 확인하세요.
                        </p>
                    </div>
                </div>
            </div>
            {% endif %}
        {% endif %}
    {% else %}
        <div class="no-result-message">
            <p>결과가 없습니다.</p>
        </div>
    {% endif %}
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const guButtons = document.querySelectorAll('.select-gu-button');
        const modelButtons = document.querySelectorAll('.model-button');
        const accuracyGraphContainer = document.querySelector('.accuracy-graph-container');
        const guNameElement = document.getElementById('gu-name');
        const predictionGraph = document.getElementById('prediction-graph');
        const accuracyMetrics = document.getElementById('accuracy-metrics');
        const initialMessage = document.getElementById('initial-message');
        
        // 전세/월세 테이블 관련 로직 (기존 코드와 동일)
        const showJeonseBtn = document.getElementById('show-jeonse-btn');
        const jeonseTableDiv = document.getElementById('jeonse-table-container');
        const showWolseBtn = document.getElementById('show-wolse-btn');
        const wolseTableDiv = document.getElementById('wolse-table-container');

        showJeonseBtn.addEventListener('click', function() {
            jeonseTableDiv.style.display = jeonseTableDiv.style.display === 'block' ? 'none' : 'block';
            wolseTableDiv.style.display = 'none';
        });

        showWolseBtn.addEventListener('click', function() {
            wolseTableDiv.style.display = wolseTableDiv.style.display === 'block' ? 'none' : 'block';
            jeonseTableDiv.style.display = 'none';
        });

        // json_script를 사용하여 안전하게 데이터 가져오기
        const prophetScript = document.getElementById('prophet_data');
        const linearRegressionScript = document.getElementById('linear_regression_data');
        const randomForestScript = document.getElementById('random_forest_data');

        const prophetData = prophetScript ? JSON.parse(prophetScript.textContent) : {};
        const linearRegressionData = linearRegressionScript ? JSON.parse(linearRegressionScript.textContent) : {};
        const randomForestData = randomForestScript ? JSON.parse(randomForestScript.textContent) : {};

        const allModelData = {
            'prophet': prophetData,
            'linear_regression': linearRegressionData,
            'random_forest': randomForestData
        };

        // 초기 선택값 설정
        let selectedGu = guButtons.length > 0 ? guButtons[0].getAttribute('data-gu') : null;
        let selectedModel = 'prophet';

        // 초기 'prophet' 모델 버튼 활성화
        const initialModelButton = document.querySelector('.model-button[data-model="prophet"]');
        if (initialModelButton) {
            initialModelButton.classList.add('active');
        }

        

        // 초기 '구' 버튼 활성화 및 데이터 표시
        if (selectedGu) {
            guButtons[0].classList.add('active');
            displayData(selectedGu, selectedModel);
        } else {
            initialMessage.style.display = 'block';
            accuracyGraphContainer.style.display = 'none';
        }

        // 구 버튼 클릭 이벤트 리스너
        guButtons.forEach(button => {
            button.addEventListener('click', function() {
                guButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                selectedGu = this.getAttribute('data-gu');
                displayData(selectedGu, selectedModel);
            });
        });

        // 모델 버튼 클릭 이벤트 리스너
        modelButtons.forEach(button => {
            button.addEventListener('click', function() {
                modelButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                selectedModel = this.getAttribute('data-model');
                if (selectedGu) {
                    displayData(selectedGu, selectedModel);
                }
            });
        });
        
        // 선택된 '구'와 '모델'에 대한 데이터를 표시하는 함수
        function displayData(gu, model) {
            const modelData = allModelData[model];
            const metrics = modelData && modelData.accuracy ? modelData.accuracy[gu] : null;
            const graphUrl = modelData && modelData.graph_urls ? modelData.graph_urls[gu] : null;

            guNameElement.textContent = gu;
            //SinitialMessage.style.display = 'none';
            accuracyGraphContainer.style.display = 'block';

            if (graphUrl) {
                // 그래프가 있는 경우에만 표시
               // predictionGraph.style.display = 'block';
                predictionGraph.src = graphUrl;
                predictionGraph.alt = `${gu} ${model} 모델 예측 그래프`;

                // 정확도 지표가 유효하지 않을 경우 '데이터 부족'으로 표시
                const mae = (metrics && isFinite(metrics.MAE)) ? (metrics.MAE).toFixed(2) : '데이터 부족';
                const rmse = (metrics && isFinite(metrics.RMSE)) ? (metrics.RMSE).toFixed(2) : '데이터 부족';
                const mape = (metrics && isFinite(metrics.MAPE)) ? (metrics.MAPE).toFixed(2) + '%' : '데이터 부족';

                accuracyMetrics.innerHTML = `
                    <div class="accuracy-list-item">
                        <h4>MAE (평균 절대 오차)</h4>
                        <p>${mae}</p>
                    </div>
                    <div class="accuracy-list-item">
                        <h4>RMSE (평균 제곱근 오차)</h4>
                        <p>${rmse}</p>
                    </div>
                    <div class="accuracy-list-item">
                        <h4>MAPE (%) (평균 절대 백분율 오차)</h4>
                        <p>${mape}</p>
                    </div>
                `;
            } else {
                // 그래프 URL이 없는 경우
                predictionGraph.style.display = 'none';
                accuracyMetrics.innerHTML = `
                    <p style="text-align: center; color: #7f8c8d; padding: 20px;">
                        이 구는 데이터가 부족하여 예측 결과를 표시할 수 없습니다.
                    </p>
                `;
            }
        }
    });
</script>

{% endblock %}